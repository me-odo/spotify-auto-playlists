from collections import Counter
from typing import Any, Dict, List

import requests

from app.config import SPOTIFY_API_BASE
from app.core import log_info

from .auth import get_current_user_id, spotify_headers


def get_user_playlists(token_info: Dict) -> List[Dict]:
    playlists = []
    url = f"{SPOTIFY_API_BASE}/me/playlists"
    headers = spotify_headers(token_info)
    params = {"limit": 50}

    while url:
        r = requests.get(url, headers=headers, params=params)
        r.raise_for_status()
        data = r.json()
        playlists.extend(data["items"])
        url = data.get("next")
        params = None

    log_info(f"{len(playlists)} playlists found.")
    return playlists


def list_user_playlists(token_info: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Return a simplified view of the current user's playlists.

    Each playlist dict contains:
      - id: Spotify playlist id
      - name: playlist name
      - owner: display name or id of the owner
      - tracks_total: number of tracks in the playlist
      - is_owned: True if owned by the current user
    """
    current_user_id = get_current_user_id(token_info)
    raw_playlists = get_user_playlists(token_info)

    result: List[Dict[str, Any]] = []
    for p in raw_playlists:
        owner_info = p.get("owner") or {}
        owner_display = owner_info.get("display_name") or owner_info.get("id") or ""
        tracks_total = (p.get("tracks") or {}).get("total") or 0
        is_owned = owner_info.get("id") == current_user_id

        result.append(
            {
                "id": p.get("id"),
                "name": p.get("name"),
                "owner": owner_display,
                "tracks_total": int(tracks_total),
                "is_owned": bool(is_owned),
            }
        )

    log_info(f"Prepared {len(result)} user playlists for API consumption.")
    return result


def find_or_create_playlist(
    token_info: Dict,
    user_id: str,
    name: str,
    existing_playlists: List[Dict],
) -> str:
    """
    Return the playlist ID for `name`, creating it if needed.

    - Reuses an existing playlist with the same name if found.
    - Otherwise, creates a new private playlist and appends it to `existing_playlists`.
    """
    headers = spotify_headers(token_info)

    # Search existing playlists
    for p in existing_playlists:
        if p.get("name") == name:
            return p["id"]

    # Create playlist
    url = f"{SPOTIFY_API_BASE}/users/{user_id}/playlists"
    payload = {
        "name": name,
        "public": False,
        "description": "Playlist automatically generated by spotify-auto-playlists (mood/genre/year).",
    }
    r = requests.post(url, headers=headers, json=payload)
    r.raise_for_status()
    playlist = r.json()
    existing_playlists.append(playlist)

    log_info(f"Created new playlist: {name}")
    return playlist["id"]


def get_playlist_tracks(token_info: Dict, playlist_id: str) -> List[str]:
    """
    Return the list of track IDs for a given playlist.
    """
    headers = spotify_headers(token_info)
    url = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    params = {"fields": "items(track(id)),next"}
    track_ids: List[str] = []

    while url:
        r = requests.get(url, headers=headers, params=params)
        r.raise_for_status()
        data = r.json()
        for item in data.get("items", []):
            track = item.get("track")
            if track and track.get("id"):
                track_ids.append(track["id"])
        url = data.get("next")
        params = None  # next URL already includes params

    return track_ids


def _fetch_all_playlist_item_uris(token_info: Dict, playlist_id: str) -> List[str]:
    """
    Fetch all track URIs currently in a playlist.
    """
    headers = spotify_headers(token_info)
    url_items = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    params = {"fields": "items(track(uri)),next"}
    uris: List[str] = []

    while url_items:
        r = requests.get(url_items, headers=headers, params=params)
        r.raise_for_status()
        data = r.json()
        for item in data.get("items", []):
            track = item.get("track")
            if track and track.get("uri"):
                uris.append(track["uri"])
        url_items = data.get("next")
        params = None  # next URL already includes params

    return uris


def _remove_tracks_by_uri(
    token_info: Dict,
    playlist_id: str,
    uris: List[str],
) -> None:
    """
    Remove all given track URIs from a playlist in batches of 100.
    """
    if not uris:
        return

    headers = spotify_headers(token_info)
    url_remove = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"

    remaining = list(uris)
    while remaining:
        batch = remaining[:100]
        remaining = remaining[100:]
        body = {"tracks": [{"uri": u} for u in batch]}
        r = requests.delete(url_remove, headers=headers, json=body)
        r.raise_for_status()


def _deduplicate_track_ids(track_ids: List[str]) -> List[str]:
    """
    Deduplicate track IDs while preserving their original order.
    """
    seen = set()
    unique_ids: List[str] = []
    for tid in track_ids:
        if tid and tid not in seen:
            seen.add(tid)
            unique_ids.append(tid)
    return unique_ids


def _add_tracks_by_ids(
    token_info: Dict,
    playlist_id: str,
    track_ids: List[str],
) -> None:
    """
    Add the given track IDs to a playlist in batches of 100.
    """
    if not track_ids:
        return

    headers = spotify_headers(token_info)
    uris = [f"spotify:track:{tid}" for tid in track_ids]
    url_add = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"

    for i in range(0, len(uris), 100):
        batch = uris[i : i + 100]
        r = requests.post(url_add, headers=headers, json={"uris": batch})
        r.raise_for_status()


def set_playlist_tracks(
    token_info: Dict, playlist_id: str, track_ids: List[str]
) -> None:
    """
    Replace playlist contents with a given set of tracks.
    - Remove all existing tracks in batches of 100.
    - Add new tracks (deduplicated) in batches of 100.
    """
    # 1) Fetch and remove all existing tracks
    uris_to_remove = _fetch_all_playlist_item_uris(token_info, playlist_id)
    _remove_tracks_by_uri(token_info, playlist_id, uris_to_remove)

    # 2) Deduplicate incoming IDs and add them
    unique_ids = _deduplicate_track_ids(track_ids)
    if not unique_ids:
        return

    _add_tracks_by_ids(token_info, playlist_id, unique_ids)


def _get_existing_ids_and_duplicates(
    token_info: Dict,
    playlist_id: str,
) -> tuple[List[str], List[str]]:
    """
    Fetch current playlist track IDs and detect duplicates.
    """
    existing_ids = get_playlist_tracks(token_info, playlist_id)
    counts = Counter(existing_ids)
    duplicates = [tid for tid, c in counts.items() if c > 1]
    return existing_ids, duplicates


def _remove_duplicate_tracks_fully(
    token_info: Dict,
    playlist_id: str,
    duplicates: List[str],
) -> None:
    """
    Remove all duplicated tracks from a playlist, if any.
    """
    if not duplicates:
        return

    headers = spotify_headers(token_info)
    url_remove = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    tracks_to_remove = [{"uri": f"spotify:track:{tid}"} for tid in duplicates]

    # Remove in batches of 100
    remaining = tracks_to_remove
    while remaining:
        batch = remaining[:100]
        remaining = remaining[100:]
        r = requests.delete(url_remove, headers=headers, json={"tracks": batch})
        r.raise_for_status()

    log_info(f"Removed {len(duplicates)} duplicated tracks from playlist.")


def _compute_tracks_to_add(
    existing_ids: List[str],
    target_ids: List[str],
    duplicates: List[str],
) -> List[str]:
    """
    Compute which track IDs should be added to reach the target playlist state.
    """
    existing_set = set(existing_ids) - set(duplicates)
    target_set = set(target_ids)
    return list(target_set - existing_set)


def incremental_update_playlist(
    token_info: Dict, playlist_id: str, target_ids: List[str]
) -> None:
    """
    Incrementally update a playlist:
      - remove existing duplicates (tracks present more than once)
      - add only tracks that are not already present

    âš  Does NOT remove tracks that are present but not in target_ids.
    """
    # 1) Fetch current playlist state and detect duplicates
    existing_ids, duplicates = _get_existing_ids_and_duplicates(
        token_info=token_info,
        playlist_id=playlist_id,
    )

    # 2) Remove duplicated tracks entirely
    _remove_duplicate_tracks_fully(
        token_info=token_info,
        playlist_id=playlist_id,
        duplicates=duplicates,
    )

    # 3) Compute which tracks need to be added
    to_add = _compute_tracks_to_add(
        existing_ids=existing_ids,
        target_ids=target_ids,
        duplicates=duplicates,
    )

    if not to_add:
        log_info("Playlist already up to date (no new tracks to add).")
        return

    # 4) Add new tracks
    _add_tracks_by_ids(token_info, playlist_id, to_add)

    log_info(f"Added {len(to_add)} new tracks to playlist.")
