from collections import Counter
import requests
from typing import Dict, List


from app.core.cli_utils import (
    print_info,
)
from app.spotify.auth import spotify_headers
from app.config import (
    SPOTIFY_API_BASE,
)


def get_user_playlists(token_info: Dict) -> List[Dict]:
    playlists = []
    url = f"{SPOTIFY_API_BASE}/me/playlists"
    headers = spotify_headers(token_info)
    params = {"limit": 50}

    while url:
        r = requests.get(url, headers=headers, params=params)
        r.raise_for_status()
        data = r.json()
        playlists.extend(data["items"])
        url = data.get("next")
        params = None

    print_info(f"{len(playlists)} playlists found.")
    return playlists


def find_or_create_playlist(
    token_info: Dict,
    user_id: str,
    name: str,
    existing_playlists: List[Dict],
) -> str:
    """
    Return the playlist ID for `name`, creating it if needed.

    - Reuses an existing playlist with the same name if found.
    - Otherwise, creates a new private playlist and appends it to `existing_playlists`.
    """
    headers = spotify_headers(token_info)

    # Search existing playlists
    for p in existing_playlists:
        if p.get("name") == name:
            return p["id"]

    # Create playlist
    url = f"{SPOTIFY_API_BASE}/users/{user_id}/playlists"
    payload = {
        "name": name,
        "public": False,
        "description": "Playlist automatically generated by spotify-auto-playlists (mood/genre/year).",
    }
    r = requests.post(url, headers=headers, json=payload)
    r.raise_for_status()
    playlist = r.json()
    existing_playlists.append(playlist)

    print_info(f"Created new playlist: {name}")
    return playlist["id"]


def get_playlist_tracks(token_info: Dict, playlist_id: str) -> List[str]:
    """
    Return the list of track IDs for a given playlist.
    """
    headers = spotify_headers(token_info)
    url = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    params = {"fields": "items(track(id)),next"}
    track_ids: List[str] = []

    while url:
        r = requests.get(url, headers=headers, params=params)
        r.raise_for_status()
        data = r.json()
        for item in data.get("items", []):
            track = item.get("track")
            if track and track.get("id"):
                track_ids.append(track["id"])
        url = data.get("next")
        params = None  # next URL already includes params

    return track_ids


def set_playlist_tracks(
    token_info: Dict, playlist_id: str, track_ids: List[str]
) -> None:
    """
    Replace playlist contents with a given set of tracks.
    - Remove all existing tracks in batches of 100.
    - Add new tracks (deduplicated) in batches of 100.
    """
    headers = spotify_headers(token_info)

    # 1) Fetch all current items
    url_items = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    params = {"fields": "items(track(uri)),next"}
    uris_to_remove: List[str] = []

    while url_items:
        r = requests.get(url_items, headers=headers, params=params)
        r.raise_for_status()
        data = r.json()
        for item in data.get("items", []):
            track = item.get("track")
            if track and track.get("uri"):
                uris_to_remove.append(track["uri"])
        url_items = data.get("next")
        params = None  # next URL already includes params

    # 2) Remove all existing tracks in batches of 100
    url_remove = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    while uris_to_remove:
        batch = uris_to_remove[:100]
        uris_to_remove = uris_to_remove[100:]
        body = {"tracks": [{"uri": u} for u in batch]}
        r = requests.delete(url_remove, headers=headers, json=body)
        r.raise_for_status()

    # 3) Deduplicate track_ids while preserving order
    seen = set()
    unique_ids: List[str] = []
    for tid in track_ids:
        if tid and tid not in seen:
            seen.add(tid)
            unique_ids.append(tid)

    if not unique_ids:
        return

    # 4) Add new tracks in batches of 100
    uris = [f"spotify:track:{tid}" for tid in unique_ids]
    url_add = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    for i in range(0, len(uris), 100):
        batch = uris[i : i + 100]
        r = requests.post(url_add, headers=headers, json={"uris": batch})
        r.raise_for_status()


def incremental_update_playlist(
    token_info: Dict, playlist_id: str, target_ids: List[str]
) -> None:
    """
    Incrementally update a playlist:
      - remove existing duplicates (tracks present more than once)
      - add only tracks that are not already present

    âš  Does NOT remove tracks that are present but not in target_ids.
    """
    headers = spotify_headers(token_info)

    # 1) Fetch current playlist state
    existing_ids = get_playlist_tracks(token_info, playlist_id)
    counts = Counter(existing_ids)

    # 2) Detect duplicates (tracks with count > 1)
    duplicates = [tid for tid, c in counts.items() if c > 1]

    # 3) Remove duplicated tracks entirely
    if duplicates:
        url_remove = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
        tracks_to_remove = [{"uri": f"spotify:track:{tid}"} for tid in duplicates]
        # Remove in batches of 100
        while tracks_to_remove:
            batch = tracks_to_remove[:100]
            tracks_to_remove = tracks_to_remove[100:]
            r = requests.delete(url_remove, headers=headers, json={"tracks": batch})
            r.raise_for_status()

        print_info(f"Removed {len(duplicates)} duplicated tracks from playlist.")

    # 4) Recompute conceptual state after duplicate removal
    existing_set = set(existing_ids) - set(duplicates)
    target_set = set(target_ids)

    # 5) Tracks to add = those in target but not already present
    to_add = list(target_set - existing_set)

    if not to_add:
        print_info("Playlist already up to date (no new tracks to add).")
        return

    # 6) Add new tracks
    uris = [f"spotify:track:{tid}" for tid in to_add]
    url_add = f"{SPOTIFY_API_BASE}/playlists/{playlist_id}/tracks"
    for i in range(0, len(uris), 100):
        batch = uris[i : i + 100]
        r = requests.post(url_add, headers=headers, json={"uris": batch})
        r.raise_for_status()

    print_info(f"Added {len(to_add)} new tracks to playlist.")
